// Generated by CoffeeScript 1.10.0
var Cursor, Game, GridUtil, Layers, Liq, Mech, Menu, Scene, Stage, Timers, Visuals, actionKey, calculated, coordToPix, generate, onFrame, onKeyDown, proceedKey, returnKey, setting,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Array.prototype.remove = function(o) {
  if (this.indexOf(o) >= 0) {
    return this.splice(this.indexOf(o), 1);
  } else {
    return console.error("Element not in array!");
  }
};

Math.randInt = function(min, max) {
  return min + Math.floor(Math.random() * (max - min + 1));
};

window.time = 0;

setting = {
  game: {
    height: 480,
    width: 640,
    gridInterval: 20,
    gridColor: 'silver',
    gridWidth: 1,
    cursorColor: new Color(0.9, 0.9, 0.2, 0.4),
    crossRadius: 4,
    crossColor: 'black',
    crossWidth: 0.8,
    backWallColor: new Color(0, 0, 0, 0.2),
    inletColor: new Color(0, 0, 1, 0.5),
    outletColor: new Color(1, 0, 0, 0.5),
    wallWidth: 2,
    wallPermaColor: new Color(0.5, 0, 0),
    liquidColor: new Color(0, 0.3, 0.9, 0.5)
  },
  menu: {
    xpos: 620,
    xSelectOffset: 30,
    ypos: 240,
    yint: 20,
    textColor: 'black',
    fontFamily: '"Palatino Linotype", "Book Antiqua", Palatino, serif',
    justification: 'right',
    fontSize: 20
  },
  textBox: {
    loadPause: .2,
    letterPause: .05,
    arrowPause: .2,
    jitterSpeed: .1,
    berth: 30,
    jitter: 3,
    height: 120,
    fillColor: 'silver',
    strokeColor: 'grey',
    faceXOffset: 20,
    faceHeight: 176,
    textOffset: [20, 20],
    fontSize: 20
  }
};

calculated = {
  facePos: (function() {
    return [78 + setting.textBox.berth + setting.textBox.faceXOffset, 88 + setting.game.height - setting.textBox.berth - setting.textBox.height - setting.textBox.faceHeight];
  })(),
  resolution: (function() {
    var R;
    R = [Math.floor(setting.game.width / setting.game.gridInterval), Math.floor(setting.game.height / setting.game.gridInterval)];
    console.log("Grid has resolution " + R[0] + ", " + R[1] + ".");
    return R;
  })()
};

Timers = {
  list: [],
  add: function(timer) {
    return this.list.push(timer);
  },
  remove: function(name) {
    return this.list.forEach(function(x, i, a) {
      if (x.name === name) {
        return a.splice(i, 1);
      }
    });
  }
};

coordToPix = function(coord) {
  if (!Number.isNaN(coord[0])) {
    return [coord[0] * setting.game.gridInterval, coord[1] * setting.game.gridInterval];
  } else if (!Number.isNaN(coord.x)) {
    return [coord.x * setting.game.gridInterval, coord.y * setting.game.gridInterval];
  } else {
    return console.err("Attempted to transform " + coord + " from grid coordinates into pixels, but failed!");
  }
};

Layers = {
  backlight: new Layer(),
  background: new Layer(),
  grid: new Layer(),
  backWall: new Layer(),
  holes: new Layer(),
  cover: new Layer(),
  liquid: new Layer(),
  construct: new Layer(),
  rope: new Layer(),
  mechanism: new Layer(),
  cursor: new Layer(),
  textBox: new Layer(),
  text: new Layer(),
  faces: new Layer(),
  overlay: new Layer()
};

Layers.background.activate();

GridUtil = {
  onStage: function(x, y) {
    return x >= 0 && x < Game.currStage.grid.length && y >= 0 && y < Game.currStage.grid[0].length;
  },
  hasElem: function(x, y, elem, xoff, yoff) {
    if (xoff == null) {
      xoff = 0;
    }
    if (yoff == null) {
      yoff = 0;
    }
    return Game.currStage.grid[x + xoff][y + yoff][elem] != null;
  },
  exhaustIfPossible: function(tile) {
    if ((tile.hole != null) && tile.hole.type === -1) {
      return tile.hole.ticker.push(Game.currStage.tick);
    }
  },
  flowD: function(liq, tile, grid, x, y) {
    this.trail(tile);
    if (!this.onStage(x, y + 1)) {
      return console.err("tile out of bounds!");
    }
    grid[x][y + 1].liq = liq;
    liq.segm.curr[2].point.y += game.setting.gridInterval;
    liq.segm.curr[3].point.y += game.setting.gridInterval;
    return liq.dir = 0;
  },
  flowL: function(liq, tile, grid, x, y) {
    this.trail(tile);
    if (!this.onStage(x - 1, y)) {
      return console.err("tile out of bounds!");
    }
    grid[x - 1][y].liq = liq;
    liq.dir = 1;
    liq.segm.curr[0].point.x -= game.setting.gridInterval;
    return liq.segm.curr[3].point.x -= game.setting.gridInterval;
  },
  flowR: function(liq, tile, grid, x, y) {
    this.trail(tile);
    if (!this.onStage(x + 1, y)) {
      return console.err("tile out of bounds!");
    }
    grid[x + 1][y].liq = liq;
    liq.dir = 2;
    liq.segm.curr[1].point.x += game.setting.gridInterval;
    return liq.segm.curr[2].point.x += game.setting.gridInterval;
  },
  flowLD: function(liq, tile, grid, x, y) {
    this.trail(tile);
    if (!this.onStage(x - 1, y)) {
      return console.err("tile out of bounds!");
    }
    if (!this.onStage(x - 1, y + 1)) {
      return console.err("tile out of bounds!");
    }
    grid[x - 1][y + 1].liq = liq;
    return liq.dir = 1;
  },
  flowLR: function(liq, tile, grid, x, y) {
    this.trail(tile);
    if (!this.onStage(x + 1, y)) {
      return console.err("tile out of bounds!");
    }
    if (!this.onStage(x + 1, y + 1)) {
      return console.err("tile out of bounds!");
    }
    grid[x + 1][y + 1].liq = liq;
    return liq.dir = 2;
  },
  stopFlow: function(liq, tile, array, index) {
    this.trail(tile);
    return array.splice(index, 1);
  },
  trail: function(tile) {
    tile.trail = true;
    return tile.liq = null;
  }
};

Mech = {
  enable: false,
  hole: function(type, label, x, y) {
    var hole;
    Layers.holes.activate();
    hole = new Path.Circle({
      center: (function() {
        var R;
        R = coordToPix([x, y]);
        R[0] += Math.floor(setting.game.gridInterval / 2);
        R[1] += Math.floor(setting.game.gridInterval / 2);
        return R;
      })(),
      radius: Math.floor((setting.game.gridInterval * 2) / 5),
      fillColor: type === 1 ? setting.game.inletColor : setting.game.outletColor,
      visible: false
    });
    hole.type = type;
    hole.label = label;
    hole.x = x;
    hole.y = y;
    hole.ticker = [];
    console.log("generated " + (hole.type === 1 ? 'inlet' : 'outlet') + " \'" + label + "\' at " + hole.x + ", " + hole.y);
    return hole;
  },
  cover: function() {},
  wedge: function(dir) {
    this.dir = dir;
  },
  splitter: function() {},
  rope: function(dir) {
    this.dir = dir;
  },
  gate: function(dir) {
    this.dir = dir;
  },
  wheel: function() {},
  tick: function() {
    Game.currStage.tick++;
    Game.currStage.liq.forEach(function(liq, i, a) {
      var tile;
      tile = Game.currStage.grid[liq.x][liq.y];
      if (tile.Z) {
        liq.dir = 1;
      }
      if (tile.Y) {
        liq.dir = 2;
      }
      if (liq.dir === 0) {
        if (tile.D) {
          if (!tile.L && !tile.Z) {
            GridUtil.flowL(liq, tile, Game.currStage.grid, x, y);
          }
          if (!tile.R && !tile.Y) {
            GridUtil.flowR(liq, tile, Game.currStage.grid, x, y);
          }
          if (tile.L && tile.R && !tile.Z && !tile.Y) {
            GridUtil.exhaustIfPossible(tile);
          }
          return Grid.Util.stopFlow(liq, tile, a, i);
        } else {
          return GridUtil.flowD(liq, tile, Game.currStage.grid, x, y);
        }
      } else if (liq.dir === 1) {
        if (!tile.L && !tile.Y) {
          if (!Game.currStage.grid[liq.x - 1][liq.y].D) {
            GridUtil.flowLD(liq, tile, Game.currStage.grid, x, y);
          } else {
            GridUtil.flowL(liq, tile, Game.currStage.grid, x, y);
          }
        } else if (!tile.D && !tile.Z && !tile.Y) {
          GridUtil.flowD(liq, tile, Game.currStage.grid, x, y);
        } else if (!tile.R && !tile.Z) {
          GridUtil.flowR(liq, tile, Game.currStage.grid, x, y);
        } else {
          GridUtil.exhaustIfPossible(tile);
        }
        return GridUtil.stopFlow(liq, tile, a, i);
      } else if (liq.dir === 2) {
        if (!tile.R && !tile.Z) {
          if (!Game.currStage.grid[liq.x + 1][liq.y].D) {
            GridUtil.flowRD(liq, tile, Game.currStage.grid, x, y);
          } else {
            GridUtil.flowR(liq, tile, Game.currStage.grid, x, y);
          }
        } else if (!tile.D && !tile.Z && !tile.Y) {
          GridUtil.flowD(liq, tile, Game.currStage.grid, x, y);
        } else if (!tile.L && !tile.Y) {
          GridUtil.flowL(liq, tile, Game.currStage.grid, x, y);
        } else {
          GridUtil.exhaustIfPossible(tile);
        }
        return GridUtil.stopFlow(liq, tile, a, i);
      }
    });
    Game.currStage.holes.forEach(function(hole, i, a) {
      var tile;
      tile = Game.currStage.grid[hole.x][hole.y];
      if ((tile.liq == null) && !tile.trail && hole.type === 1) {
        return tile.liq = new Liq(1, hole.x, hole.y);
      }
    });
    console.log("advanced hydraulics simulation");
  }
};

Liq = function(type, x, y) {
  var liq;
  liq = {
    dir: 0,
    type: type
  };
  liq.segm = {
    origin: [new Segment(coordToPix([x, y])), new Segment(coordToPix([x + 1, y])), new Segment(coordToPix([x + 1, y + 1])), new Segment(coordToPix([x, y + 1]))]
  };
  liq.segm.curr = [liq.segm.origin[0], liq.segm.origin[1], liq.segm.origin[2], liq.segm.origin[3]];
  return liq.path = (function() {
    var p;
    Layers.liquid.activate();
    return p = new Path({
      segments: liq.segm.origin,
      fillColor: setting.game.liquidColor
    });
  })();
};

generate = {
  raster: function(id, pos, visible) {
    var r;
    r = new Raster(id);
    r.position = pos;
    r.visible = visible;
    return r;
  },
  menuText: function(yoffset, content) {
    var preselect, xpos;
    xpos = setting.menu.xpos;
    preselect = yoffset === Menu.cursor;
    if (preselect) {
      xpos -= setting.menu.xSelectOffset;
    }
    return new PointText({
      position: [xpos, setting.menu.ypos + yoffset * setting.menu.yint],
      fontFamily: setting.menu.fontFamily,
      justification: setting.menu.justification,
      fontSize: setting.menu.fontSize,
      textColor: setting.menu.textColor,
      content: content
    });
  },
  timer: function(name, seconds, event, repeat) {
    var timer;
    if (repeat == null) {
      repeat = false;
    }
    timer = {
      name: name,
      target: window.time + seconds,
      interval: seconds,
      event: event,
      repeat: repeat
    };
    Timers.add(timer);
  },
  tile: function() {
    return {};
  },
  stage: function(name, height, width, holes) {
    var column, j, k, l, leftTile, len, len1, len2, len3, m, ref, ref1, ref2, ref3, stage;
    console.log("generating stage " + name);
    stage = {
      tick: 0,
      name: name,
      height: height,
      width: width,
      grid: (function() {
        var column, grid, j, k, ref, ref1, x, y;
        grid = [];
        for (x = j = 0, ref = width - 1; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
          column = [];
          for (y = k = 0, ref1 = height - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
            column.push(new generate.tile());
          }
          grid.push(column);
        }
        return grid;
      })(),
      origin: (function() {
        var o;
        o = [(Math.floor(calculated.resolution[0] / 2)) - (Math.floor(width / 2)), (Math.floor(calculated.resolution[1] / 2)) - (Math.floor(height / 2))];
        console.log("origin is " + o);
        return o;
      })(),
      liq: [],
      active: false
    };
    stage.holes = (function() {
      var hole, j, len, o;
      o = [];
      for (j = 0, len = holes.length; j < len; j++) {
        hole = holes[j];
        stage.grid[hole.x][hole.y].hole = hole;
        o.push(hole);
      }
      return o;
    })();
    ref = stage.grid[0];
    for (j = 0, len = ref.length; j < len; j++) {
      leftTile = ref[j];
      leftTile.L = 2;
    }
    ref1 = stage.grid[width - 1];
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      leftTile = ref1[k];
      leftTile.R = 2;
    }
    ref2 = stage.grid;
    for (l = 0, len2 = ref2.length; l < len2; l++) {
      column = ref2[l];
      column[0].U = 2;
    }
    ref3 = stage.grid;
    for (m = 0, len3 = ref3.length; m < len3; m++) {
      column = ref3[m];
      column[height - 1].D = 2;
    }
    stage.activate = function() {
      var center, hD, hU, hole, len4, n, ref4, wL, wR;
      if (this.active) {
        console.log("stage " + name + " already active!");
        return false;
      }
      this.active = true;
      console.log("prepping stage " + name);
      hU = -(Math.floor(height / 2));
      hD = height + hU;
      wL = -(Math.floor(width / 2));
      wR = width + wL;
      center = coordToPix([Math.floor(calculated.resolution[0] / 2), Math.floor(calculated.resolution[1] / 2)]);
      console.log("stage center is " + center);
      Visuals.game.backWall.segments[0].point.x = center[0] + (coordToPix([wL, hU]))[0];
      Visuals.game.backWall.segments[1].point.x = center[0] + (coordToPix([wR, hU]))[0];
      Visuals.game.backWall.segments[2].point.x = center[0] + (coordToPix([wR, hD]))[0];
      Visuals.game.backWall.segments[3].point.x = center[0] + (coordToPix([wL, hD]))[0];
      Visuals.game.backWall.segments[1].point.y = center[1] + (coordToPix([wR, hU]))[1];
      Visuals.game.backWall.segments[0].point.y = center[1] + (coordToPix([wL, hU]))[1];
      Visuals.game.backWall.segments[2].point.y = center[1] + (coordToPix([wR, hD]))[1];
      Visuals.game.backWall.segments[3].point.y = center[1] + (coordToPix([wL, hD]))[1];
      Layers.backWall.visible = true;
      Layers.holes.position = coordToPix(this.origin);
      Layers.liquid.position = coordToPix(this.origin);
      ref4 = this.holes;
      for (n = 0, len4 = ref4.length; n < len4; n++) {
        hole = ref4[n];
        hole.visible = true;
        console.log((hole.type === 1 ? 'inlet' : hole.type === -1 ? 'outlet' : 'ERROR') + " at " + hole.x + ", " + hole.y + " activated");
      }
      Cursor.moveTo(this.origin[0], this.origin[1]);
      Cursor.lowerBounds = this.origin;
      Cursor.upperBounds = [this.origin[0] + width, this.origin[1] + height];
      return true;
    };
    return stage;
  }
};

Visuals = {
  backlight: (function() {
    var light;
    Layers.backlight.activate();
    light = new Path([[0, 0], [setting.game.width, 0], [setting.game.width, setting.game.height], [0, setting.game.height]]);
    light.fillColor = 'white';
    return light;
  })(),
  menubg: (function() {
    Layers.background.activate();
    return generate.raster('menubg', view.center, true);
  })(),
  backboard: (function() {
    var B;
    Layers.background.activate();
    B = generate.raster('backboard', view.center, true);
    B.visible = false;
    return B;
  })(),
  game: {
    grid: (function() {
      var j, k, out, ref, ref1, ref2, ref3, x, y;
      Layers.grid.activate();
      out = [];
      for (x = j = 0, ref = setting.game.width, ref1 = setting.game.gridInterval; ref1 > 0 ? j <= ref : j >= ref; x = j += ref1) {
        out.push(new Path({
          segments: [[x, 0], [x, setting.game.height]],
          strokeColor: setting.game.gridColor,
          strokeWidth: setting.game.gridWidth
        }));
      }
      for (y = k = 0, ref2 = setting.game.height, ref3 = setting.game.gridInterval; ref3 > 0 ? k <= ref2 : k >= ref2; y = k += ref3) {
        out.push(new Path({
          segments: [[0, y], [setting.game.width, y]],
          strokeColor: setting.game.gridColor,
          strokeWidth: setting.game.gridWidth
        }));
      }
      Layers.grid.visible = false;
      return out;
    })(),
    backWall: (function() {
      Layers.backWall.activate();
      Layers.backWall.visible = false;
      return new Path({
        segments: [[0, 0], [1, 0], [1, 1], [0, 1]],
        fillColor: setting.game.backWallColor,
        strokeColor: setting.game.wallPermaColor,
        strokeWidth: setting.game.wallWidth,
        closed: true
      });
    })()
  },
  cursor: (function() {
    var cursor;
    Layers.cursor.activate();
    Layers.cursor.visible = false;
    cursor = [
      new Path({
        segments: [[0, 0], [setting.game.gridInterval, 0], [setting.game.gridInterval, setting.game.gridInterval], [0, setting.game.gridInterval]],
        fillColor: setting.game.cursorColor
      }), new Path({
        segments: [[setting.game.gridInterval / 2 + setting.game.crossRadius, setting.game.gridInterval / 2], [setting.game.gridInterval / 2 - setting.game.crossRadius, setting.game.gridInterval / 2]],
        strokeColor: setting.game.crossColor,
        strokeWidth: setting.game.crossWidth
      }), new Path({
        segments: [[setting.game.gridInterval / 2, setting.game.gridInterval / 2 + setting.game.crossRadius], [setting.game.gridInterval / 2, setting.game.gridInterval / 2 - setting.game.crossRadius]],
        strokeColor: setting.game.crossColor,
        strokeWidth: setting.game.crossWidth
      })
    ];
    Layers.cursor.position = [(Math.floor(setting.game.gridInterval * calculated.resolution[0] / 2)) + (Math.floor(setting.game.gridInterval / 2)), (Math.floor(setting.game.gridInterval * calculated.resolution[1] / 2)) + (Math.floor(setting.game.gridInterval / 2))];
    console.log("Cursor initialized at " + Layers.cursor.position);
    return cursor;
  })(),
  faces: (function() {
    Layers.faces.activate();
    return [generate.raster('face1', calculated.facePos, false), generate.raster('face2', calculated.facePos, false), generate.raster('face3', calculated.facePos, false), generate.raster('face4', calculated.facePos, false), generate.raster('face5', calculated.facePos, false)];
  })(),
  textBox: (function() {
    var anchors, box;
    Layers.textBox.activate();
    anchors = [[setting.textBox.berth, setting.game.height - setting.textBox.berth - setting.textBox.height], [setting.game.width - setting.textBox.berth, setting.game.height - setting.textBox.berth - setting.textBox.height], [setting.game.width - setting.textBox.berth, setting.game.height - setting.textBox.berth], [setting.textBox.berth, setting.game.height - setting.textBox.berth]];
    box = new Path(anchors);
    box.anchors = anchors;
    box.closed = true;
    box.fillColor = setting.textBox.fillColor;
    box.strokeColor = setting.textBox.strokeColor;
    box.visible = false;
    box.queue = "";
    box.char = 0;
    box.writing = false;
    box.pointText = (function() {
      Layers.text.activate();
      return new PointText({
        position: [anchors[0][0] + setting.textBox.textOffset[0], anchors[0][1] + setting.textBox.textOffset[1]],
        justification: 'left',
        fontSize: setting.textBox.fontSize,
        textColor: 'white'
      });
    })();
    box.reset = function() {
      this.char = 0;
      this.queue = "";
      return this.pointText.content = "";
    };
    box.type = function() {
      if (this.char < this.queue.length) {
        this.pointText.content += this.queue[this.char];
        this.char++;
        return true;
      } else {
        console.log("finished writing");
        this.writing = false;
        return false;
      }
    };
    box.skip = function() {
      this.char = this.queue.length;
      this.pointText.content = this.queue;
      this.writing = false;
      return false;
    };
    box.jitter = function() {
      if (Visuals.textBox.visible) {
        return generate.timer("textBoxJitter", setting.textBox.jitterSpeed, (function() {
          Visuals.textBox.segments.forEach(function(seg, i, a) {
            seg.point.x = Visuals.textBox.anchors[i][0] + Math.randInt(-setting.textBox.jitter, setting.textBox.jitter);
            seg.point.y = Visuals.textBox.anchors[i][1] + Math.randInt(-setting.textBox.jitter, setting.textBox.jitter);
          });
        }), true);
      }
    };
    box.calm = function() {
      return Timers.remove("textBoxJitter");
    };
    return box;
  })()
};


/*

visuals for mechanics objects are in mechanics and not here
 */

Menu = {
  enabled: true,
  cursor: 1,
  err: function() {
    return console.log("Menu function not supported.");
  },
  start: function() {
    var j, len, option, ref;
    Menu.enabled = false;
    Scene.enabled = true;
    Visuals.menubg.visible = false;
    ref = Menu.options;
    for (j = 0, len = ref.length; j < len; j++) {
      option = ref[j];
      option.visible = false;
    }
    return Scene.set(Scene.s1);
  },
  "continue": function() {
    return this.err();
  },
  load: function() {
    return this.err();
  },
  "export": function() {
    return this.err();
  },
  settings: function() {
    return this.err();
  },
  sandbox: function() {
    return this.err();
  }
};

Menu.m_start = generate.menuText(0, "NEW");

Menu.m_continue = generate.menuText(1, "CONTINUE");

Menu.m_load = generate.menuText(2, "LOAD FROM FILE");

Menu.m_export = generate.menuText(3, "SAVE TO FILE");

Menu.m_settings = generate.menuText(4, "SETTINGS");

Menu.m_sandbox = generate.menuText(5, "SANDBOX");

Menu.options = [Menu.m_start, Menu.m_continue, Menu.m_load, Menu.m_export, Menu.m_settings, Menu.m_sandbox];

Menu.select = function(selection) {
  switch (selection) {
    case Menu.m_start:
      return this.start();
    case Menu.m_continue:
      return this["continue"]();
    case Menu.m_load:
      return this.load();
    case Menu.m_export:
      return this["export"]();
    case Menu.m_settings:
      return this.settings();
    case Menu.m_sandbox:
      return this.sandbox();
  }
};

Game = {
  info: {
    money: 100,
    inventory: {
      wall: -1,
      hole: -1,
      rope: -2,
      sluice: -2,
      wedge: -2,
      wheel: -2
    }
  },
  currStage: null,
  activate: function() {
    Layers.grid.visible = true;
    Layers.cursor.visible = true;
    Visuals.backboard.visible = true;
    return this.currStage.activate();
  },
  deactivate: function() {
    Layers.grid.visible = false;
    Layers.cursor.visible = false;
    return Visuals.backboard.visible = false;
  },
  set: function(stage) {
    return this.currStage = stage;
  }
};

Stage = {
  testing: generate.stage("testing", 5, 5, [new Mech.hole(1, 'input', 2, 0), new Mech.hole(-1, 'output', 2, 4)])
};

Cursor = {
  lowerBounds: [0, 0],
  upperBounds: calculated.resolution,
  coordinate: [Math.floor(calculated.resolution[0] / 2), Math.floor(calculated.resolution[1] / 2)],
  move: function(x, y) {
    var i, j, len, ref;
    ref = [0, 1];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      this.coordinate[i] += (i === 0 ? x : y);
      if (this.coordinate[i] >= this.upperBounds[i]) {
        this.coordinate[i] -= this.upperBounds[i] - this.lowerBounds[i];
      }
      if (this.coordinate[i] < this.lowerBounds[i]) {
        this.coordinate[i] += this.upperBounds[i] - this.lowerBounds[i];
      }
    }
    console.log("Moved cursor to position " + this.coordinate);
    Layers.cursor.position.x = setting.game.gridInterval * this.coordinate[0] + (Math.floor(setting.game.gridInterval / 2));
    return Layers.cursor.position.y = setting.game.gridInterval * this.coordinate[1] + (Math.floor(setting.game.gridInterval / 2));
  },
  moveTo: function(x, y) {
    return this.move(x - this.coordinate[0], y - this.coordinate[1]);
  },
  up: function() {
    return this.move(0, -1);
  },
  down: function() {
    return this.move(0, 1);
  },
  left: function() {
    return this.move(-1, 0);
  },
  right: function() {
    return this.move(1, 0);
  },
  currentItem: Mech.wall,
  select: function() {
    return 0;
  },
  enabled: false
};

Scene = {
  enabled: false,
  write: function(char, text) {
    Visuals.textBox.visible = true;
    Visuals.textBox.queue = text;
    if (!Visuals.textBox.writing) {
      Visuals.textBox.writing = true;
      generate.timer("startWriting", setting.textBox.loadPause, (function() {
        return generate.timer("writing", setting.textBox.letterPause, (function() {
          if (!Visuals.textBox.type()) {
            return Timers.remove("writing");
          }
        }), true);
      }));
    }
    Visuals.faces.forEach(function(x, i, a) {
      if (i === char) {
        x.visible = true;
      } else {
        x.visible = false;
      }
    });
  },
  set: function(scene) {
    var position;
    this.activeScene = scene;
    position = 0;
    Visuals.textBox.visible["true"];
    return this.read();
  },
  activeScene: null,
  activeFace: -1,
  position: 0,
  s1: [
    [0, "HELLO WORLD."], [1, "Yep, have fun."], [0, "ACKNOWLEDGED."], function() {
      Game.set(Stage.testing);
      Game.activate();
      Scene.advance();
    }, [0, "This is the canvas on which shall be created..."], function() {
      Visuals.textBox.jitter();
      Scene.advance();
    }, [0, "The greatest invention known to the world!"], function() {
      Visuals.textBox.calm();
      Scene.advance();
    }, [0, "Managing the waterworks of this city is too much work, so\nwhy not craft an automaton of flowing water?"], function() {
      Cursor.enabled = true;
      Scene.advance();
    }, [0, "First, use the arrow keys to move the cursor."], [2, "Not saying that the spacebar advances mechanics?"], [2, "The player's not even here yet, remember..."], [0, "..."], [0, "ACKNOWLEDGED."], function() {
      Mech.enabled = true;
      Scene.end();
    }
  ],
  end: function() {
    console.log("Scene has ended.");
    Visuals.textBox.visible = false;
    return Visuals.faces.forEach(function(x, i, a) {
      x.visible = false;
    });
  },
  read: function() {
    if (this.activeScene[this.position] instanceof Array) {
      this.write(this.activeScene[this.position][0], this.activeScene[this.position][1]);
      return true;
    } else if (this.activeScene[this.position] instanceof Function) {
      this.activeScene[this.position]();
      return false;
    }
  },
  advance: function() {
    console.log("Textbox is " + (!Visuals.textBox.writing ? 'not' : '') + " writing.");
    if (this.activeScene != null) {
      if (!Visuals.textBox.writing) {
        Visuals.textBox.reset();
        this.position++;
        if (this.position < this.activeScene.length) {
          return this.read();
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
  }
};

actionKey = ['enter', 'z'];

returnKey = ['escape', 'x'];

proceedKey = ['space'];

onKeyDown = function(event) {
  var ref, ref1, ref2, ref3;
  if (Menu.enabled) {
    if (event.key === 'down' || event.key === 'up') {
      Menu.options[Menu.cursor].position.x += setting.menu.xSelectOffset;
      if (event.key === 'down') {
        Menu.cursor++;
      } else {
        Menu.cursor--;
      }
      if (Menu.cursor >= Menu.options.length) {
        Menu.cursor %= Menu.options.length;
      }
      if (Menu.cursor < 0) {
        Menu.cursor += Menu.options.length;
      }
      Menu.options[Menu.cursor].position.x -= setting.menu.xSelectOffset;
    }
    if (ref = event.key, indexOf.call(actionKey, ref) >= 0) {
      Menu.select(Menu.options[Menu.cursor]);
    }
  }
  if (Scene.enabled) {
    if (ref1 = event.key, indexOf.call(actionKey, ref1) >= 0) {
      Scene.advance();
    }
    if (ref2 = event.key, indexOf.call(returnKey, ref2) >= 0) {
      Visuals.textBox.skip();
    }
  }
  if (Cursor.enabled) {
    if (event.key === 'up') {
      Cursor.up();
    }
    if (event.key === 'down') {
      Cursor.down();
    }
    if (event.key === 'left') {
      Cursor.left();
    }
    if (event.key === 'right') {
      Cursor.right();
    }
  }
  if (Mech.enabled) {
    if (ref3 = event.key, indexOf.call(proceedKey, ref3) >= 0) {
      return Mech.tick();
    }
  }
};

onFrame = function(event) {
  window.time = event.time;
  if (Timers.list.length !== 0) {
    return Timers.list.forEach(function(x, i, a) {
      while (x.target <= event.time && x.target !== -1) {
        console.log("fired timer " + x.name);
        x.event();
        if (x.repeat) {
          x.target += x.interval;
        } else {
          x.target = -1;
          a.splice(i, 1);
        }
      }
    });
  }
};
